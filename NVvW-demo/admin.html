<!DOCTYPE html>
<meta charset="utf-8">

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<style>
#links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

#nodes circle {
  stroke: #000;
  stroke-width: 1.5px;
}

#nodes g.win circle {
  fill: green;
}

#links line.percolating {
  stroke-width: 5px;
  stroke: blue;
}

#links line.survived {
  stroke-width: 3px;
  stroke: green;
}


</style>
<body>
  <div class="row">
    <button class="col-md-9 col-sm-12 btn btn-danger" onclick="percolate()">
      DO PERCOLATION
    </button>
    <input type="range" class="custom-range col-md-3" min="1" max="10" id="speed" value="1" onchange="updateSpeed(this.value)">
  </div>
  <div class="row">
    <div id="canvas" height="100%" class="col-md-12"></div>
  </div>
</body>
<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script>
<script>
var graph;
var containerID = "canvas";
var container = document.getElementById(containerID);
var width = container.offsetWidth,
	height = container.offsetHeight;
if (height<width) height=width;
if (height>window.innerHeight) height = window.innerHeight;
var tensionTime = 1000;
var winners;

function updateSpeed(speed) {
  tensionTime = 1000 / speed;
}

function percolate() {
  let originalIDs = [];
  let source2remaining = new Map();
  graph.links.forEach(e => originalIDs.push(link2id(e)));
  graph.nodes.forEach(n => source2remaining.set(n.id,[]));

  let percolateHttp = new XMLHttpRequest();
  percolateHttp.open("GET","./percolate");
  percolateHttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      data = JSON.parse(this.responseText);
      winners = data.winners;
      console.log(data.remainingLinks);
      console.log(source2remaining);
      data.remainingLinks.forEach(e => source2remaining.get(parseInt(e[0])).push(parseInt(e[1])));
      dramaticallyRemoveLinks(source2remaining, originalIDs, 0);
    }
  }
  percolateHttp.send();
}

function dramaticallyRemoveLinks(source2remaining,originalIDs,idx) {
  if (idx>=originalIDs.length) {
    // Notify the server that the percolation has ended
    let percolateEndedHttp = new XMLHttpRequest();
    percolateEndedHttp.open("GET","./finishPercolation");
    percolateEndedHttp.send();
    // Make winners green
    nodes.classed("win",n=>winners.includes(n.id));
    return;
  }
  let id = originalIDs[idx];
  let source = parseInt(id.substr(1).split('-')[0]);
  let target = parseInt(id.substr(1).split('-')[1]);
  let remove = !source2remaining.get(source).includes(target);
  let elem = document.getElementById(id);
  elem.classList.add('percolating');
  setTimeout(function() {
    if (remove) {
      graph.links.splice(graph.links.indexOf(elem.__data__),1);
      d3.select("#links").selectAll("line").data(graph.links,link2id).exit().remove();
      simulation = simulation.nodes(graph.nodes).force("link", d3.forceLink(graph.links).id(d => d.name));
      simulation.alpha(1).restart();
    } else {
      elem.classList.remove('percolating');
      elem.classList.add('survived');
    }
    dramaticallyRemoveLinks(source2remaining,originalIDs,idx+1);
  }, tensionTime);
}

// A mapping from node/link to its id name
var node2id = v=>`node${v.id}`;
var link2id = e=>`e${e.source.id}-${e.target.id}`;

// Update the visualization after graph is changed.
var nodes,circles,labels,links,drag,simulation,svg;
function updateVisualization() {
  links = d3.select("#links").selectAll("line").data(graph.links,link2id);
  var linkEnter = links.enter()
                       .append("line")
                       .attr("id",link2id)
                       .attr("x1",e=>e.x1)
                       .attr("y1",e=>e.y1)
                       .attr("x2",e=>e.x2)
                       .attr("y2",e=>e.y2)
                       .attr("stroke-width", 1.5);
  links.exit().remove();
  links = linkEnter.merge(links);

  nodes = d3.select("#nodes").selectAll("g").data(graph.nodes,node2id);
  var nodeEnter = nodes.enter()
                       .append("g")
                       .attr("id",node2id)
                       .attr("transform", d => "translate("+d.x+","+d.y+")")
                       .call(drag(simulation));
  circles = nodeEnter.append("circle")
                 .attr("r", 12)
                 .attr("stroke", "black")
                 .attr("fill", "red");
  labels = nodeEnter.append("text")
                .attr("stroke","black")
                .attr("stroke-width",0.5)
                .text(d => d.name)
                .attr('x', 14)
                .attr('y', 0);
  nodes.exit().remove();
  nodes = nodeEnter.merge(nodes);
  // Update the simulation elements and restart
  simulation = simulation.nodes(graph.nodes).force("link", d3.forceLink(graph.links).id(node2id));
  simulation.alpha(1).restart();
}

function showGraph() {
  drag = simulation => {
    function dragstarted(event) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }

    function dragged(event) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }

    function dragended(event) {
      if (!event.active) simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }

    return d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended);
  }

  simulation = d3.forceSimulation(graph.nodes)
                 .force("link", d3.forceLink(graph.links).id(node2id))
                 .force("boundary", forceBoundary(15,15,width-15, height-15))
                 .force("charge", d3.forceManyBody().strength(-400))
                 .force("center", d3.forceCenter(width / 2, height / 2).strength(1));
  /*simulation = d3.forceSimulation(graph.nodes)
                 .force("link", d3.forceLink(graph.links).id(node2id))
                 .force("charge", d3.forceManyBody().strength(-800))
                 .force("center", d3.forceCenter(width / 2, height / 2));*/

	svg = d3.select("#"+containerID).append("svg")
							   .attr("width", width)
							   .attr("height", height);

  links = svg.append("g").attr("id","links")
      .attr("stroke", "#999")
      .attr("stroke-opacity", 0.6);

  nodes = svg.append("g").attr("id","nodes")
                  .attr("stroke", "#fff")
                  .attr("stroke-width", 1.5);
  updateVisualization();
  simulation.on("tick", () => {
    links
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

    nodes.attr("transform", d => "translate("+d.x+","+d.y+")");
  });

}

function addNodesFromName(n) {
  graph.nodes.push({name: n, x: width/2, y: height/2})
}

function addLinksFromNeighbors(v) {
  graph.nodes.push({
    'id': v.id,
    'name': v.name,
    'x': width/2,
    'y': height/2
  });
  graph.links.push({
    source: graph.nodes[v.id],
    target: graph.nodes[v.neighbor1],
    x1: graph.nodes[v.id].x,
    y1: graph.nodes[v.id].x,
    x2: graph.nodes[v.neighbor1].x,
    y2: graph.nodes[v.neighbor1].y,
  });
  graph.links.push({
    "source": graph.nodes[v.id],
    "target": graph.nodes[v.neighbor2],
    x1: graph.nodes[v.id].x,
    y1: graph.nodes[v.id].x,
    x2: graph.nodes[v.neighbor2].x,
    y2: graph.nodes[v.neighbor2].y,
  });
}

function addLink(e) {
  e.source = graph.nodes[e.source];
  e.target = graph.nodes[e.target];
  e.x1 = e.source.x;
  e.y1 = e.source.y;
  e.x2 = e.target.x;
  e.y2 = e.target.y;
}

// Retrieve graph
var xmlHttp = new XMLHttpRequest();
xmlHttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
        graph = JSON.parse(this.responseText);
		graph.nodes.forEach(function(v) {
			v.x = width/2;
      v.y = height/2;
		});
    graph.links.forEach(addLink);
    showGraph();
  }
};
xmlHttp.open("GET", "/network/getdata");
xmlHttp.send();

</script>
