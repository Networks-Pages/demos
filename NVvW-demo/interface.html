<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <title>Network Games</title>

  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"
        integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2"
        crossorigin="anonymous">

  <style>
    #links line {
      stroke: #999;
      stroke-opacity: 0.6;
    }

    #nodes circle {
      stroke: black;
      fill: yellow;
      stroke-width: 1.5px;
    }

    #nodes g.selected circle {
      fill: blue;
    }

    #nodes g.max-degree circle {
      fill: purple;
    }

    #nodes g.lost circle {
      fill: red;
    }

    #nodes g.win circle {
      fill: green;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="row flex-column align-items-center" id="alerts"></div>
    
    <div class="row mt-3" id="instructions-container">
      <div class="col-md-12">
        <h1>Instructions</h1>
      </div>
      <div class="col-md-5">
        <p>
          In this game, each participant adds a single node to the network and chooses two neighbors that this node connects to.
          You can only connect to nodes that have <b>less than 5 neighbors</b>.
          At the end of the game, we will percolate the graph: each link will be removed with probability <i>0.5</i> (independently).
        </p>
      </div>
      <div class="col-md-7">
        <p>
          The game is won by the players whose nodes end up in the <i>largest</i> connected component after percolation. When multiple components have equal size, both win.
        </p>
        <p>
          You can <b>add your node</b> by clicking the two neighbors that you want to connect to, typing your name in the textfield and clicking the button "Add node".
        </p>
      </div>
    </div>
    
    <div class="row justify-content-center" id="add-node-container">
      <form class="form-inline mt-3">
        <label class="my-1 mr-2 sr-only" for="name">Your name</label>
        <input type="text" class="my-1 mr-2" id="name" placeholder="Your name"></input>
        <button class="btn btn-primary my-1 mr-2" onclick="addNode()">
          Add node
        </button>
        <button class="btn btn-primary my-1" onclick="updateNetwork()">
          Refresh
        </button>
      </form>
    </div>
  </div><!-- /.container -->
  <div class="container-fluid">
    <div class="row">
      <div id="canvas" height="100%" class="col-md-12 px-0"></div>
    </div>
  </div><!-- /.container-fluid -->
</body>
<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
        integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
        crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx"
        crossorigin="anonymous"></script>
<script>
// disable form submission; we handle everything using AJAX
$('form').on('submit', (e) => e.preventDefault());


var MAX_DEGREE = 5;
var userID = new URLSearchParams(window.location.search).get('id');

var graph;
var containerID = "canvas";
var container = document.getElementById(containerID);
var width = container.offsetWidth,
	height = container.offsetHeight;
if (height<width) height=width;
if (height>0.8*window.innerHeight) height = 0.8*window.innerHeight;
// Variables for selecting neighbors
var neighbor2select = false;
var neighbors = {neighbor1: true, neighbor2: true};
var selectionCursor = 0;
var selected = [false,false];
// When one of the select-buttons is pressed
// Change the label below the select-button to the node name.
function nodeSelected(e,node) {
  if (!selected.includes(node.id) && node.degree<MAX_DEGREE) {
    selectionCursor = (selectionCursor+1)%2;
    if (selected[selectionCursor]!==false) {
      document.getElementById('node'+selected[selectionCursor]).classList.remove("selected");
    }
    selected[selectionCursor] = node.id;
    console.log(e);
    console.log(selected);
    document.getElementById(node2id(node)).classList.add("selected");
  }
}
function addNode() {
  var name = document.getElementById("name").value;
  var addNodeHttp = new XMLHttpRequest();
  addNodeHttp.overrideMimeType("application/json");
  let url = "/network/addnode?name="+name+"&neighbor1="+selected[0]+"&neighbor2="+selected[1];
  if (userID) {
    url += "&id="+userID;
  }
  addNodeHttp.open("GET",url);
  addNodeHttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      document.getElementById('node'+selected[0]).classList.remove('selected');
      document.getElementById('node'+selected[1]).classList.remove('selected');
      selected = [false,false]
      updateNetwork();
      showUserAddedANode();
    } else {
      handleAjaxError(this);
    }
  }
  addNodeHttp.send();
}

function showPercolation(data) {
  graph.links = data.remainingLinks.map(function(e) { return {source: parseInt(e[0]), target: parseInt(e[1])};});
  graph.links.forEach(addLink);
  nodes.classed("win",n=>data.winners.includes(n.id));
  nodes.classed("lost",n=>!data.winners.includes(n.id));
  updateVisualization();
}

function recomputeDegrees() {
  graph.nodes.forEach(n => n.degree=0);
  graph.links.forEach(function(e) {
    e.source.degree++;
    e.target.degree++;
  });
  nodes.classed("max-degree",n=>n.degree>=MAX_DEGREE);
}


// Retrieve all newly added nodes and update the visualization
function updateNetwork() {
  var n = graph.nodes.length;
  var updateHttp = new XMLHttpRequest();
  updateHttp.overrideMimeType("application/json");
  updateHttp.open("GET","/network/updatedata?n="+n);
  updateHttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
        data = JSON.parse(this.responseText);
        data.neighbors.forEach(addLinksFromNeighbors);
        updateVisualization();
        recomputeDegrees();
    } else {
      handleAjaxError(this);
    }
  }
  updateHttp.send();
}

function createAlert(message, type = 'danger', title = 'Error.') {
  var $alert = $(`
    <div class="alert alert-${type} mt-3 alert-dismissible fade show" role="alert">
      <strong>${title}</strong> ${message}
      <button type="button" class="close" data-dismiss="alert" aria-label="Close">
        <span aria-hidden="true">&times;</span>
      </button>
    </div>
  `);
  $('#alerts').append($alert);
  $alert.alert();
}

function handleAjaxError(req) {
  if (req.readyState === 4 && req.status === 400) {
    createAlert(req.getResponseHeader('message'));
  }
}

function showUserAddedANode() {
  $('#instructions-container, #add-node-container').remove();
  createAlert('You added a node, thank you!', 'success', 'Hooray!');
}

// A mapping from node/link to its id name
var node2id = v=>`node${v.id}`;
var link2id = e=>`e${e.source.id}-${e.target.id}`;

// Update the visualization after graph is changed.
var nodes,circles,labels,links,drag,simulation,svg;
function updateVisualization() {

  links = d3.select("#links").selectAll("line").data(graph.links,link2id);
  var linkEnter = links.enter()
                       .append("line")
                       .attr("id",link2id)
                       .attr("x1",e=>e.x1)
                       .attr("y1",e=>e.y1)
                       .attr("x2",e=>e.x2)
                       .attr("y2",e=>e.y2)
                       .attr("stroke-width", 1.5);
  links.exit().remove();
  links = linkEnter.merge(links);

  nodes = d3.select("#nodes").selectAll("g").data(graph.nodes,node2id);
  var nodeEnter = nodes.enter()
                       .append("g")
                       .attr("id",node2id)
                       .attr("transform", d => "translate("+d.x+","+d.y+")")
                       .call(drag(simulation));
  circles = nodeEnter.append("circle")
                 .attr("r", 12)
                 .on("click",nodeSelected);
  labels = nodeEnter.append("text")
                .attr("stroke","black")
                .attr("stroke-width",0.5)
                .text(d => d.name)
                .attr('x', 14)
                .attr('y', 0);
  nodes.exit().remove();
  nodes = nodeEnter.merge(nodes);
  // Update the simulation elements and restart
  simulation = simulation.nodes(graph.nodes).force("link", d3.forceLink(graph.links).id(node2id));
  simulation.alpha(1).restart();
}

function showGraph() {
  drag = simulation => {
    function dragstarted(event) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }

    function dragged(event) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }

    function dragended(event) {
      if (!event.active) simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }

    return d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended);
  }

  simulation = d3.forceSimulation(graph.nodes)
                 .force("link", d3.forceLink(graph.links).id(node2id))
                 .force("boundary", forceBoundary(15,15,width-15, height-15))
                 .force("charge", d3.forceManyBody().strength(-400))
                 .force("center", d3.forceCenter(width / 2, height / 2).strength(1));
  /*simulation = d3.forceSimulation(graph.nodes)
                 .force("link", d3.forceLink(graph.links).id(node2id))
                 .force("charge", d3.forceManyBody().strength(-800))
                 .force("center", d3.forceCenter(width / 2, height / 2));*/

	svg = d3.select("#"+containerID).append("svg")
							   .attr("width", width)
							   .attr("height", height);

  links = svg.append("g").attr("id","links")
      .attr("stroke", "#999")
      .attr("stroke-opacity", 0.6);

  nodes = svg.append("g").attr("id","nodes")
                  .attr("stroke", "#fff")
                  .attr("stroke-width", 1.5);
  updateVisualization();
  simulation.on("tick", () => {
    links
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

    nodes.attr("transform", d => "translate("+d.x+","+d.y+")");
  });

}

function addNodesFromName(n) {
  graph.nodes.push({name: n, x: width/2, y: height/2})
}

function addLinksFromNeighbors(v) {
  graph.nodes.push({
    'id': v.id,
    'name': v.name,
    'x': width/2,
    'y': height/2
  });
  graph.links.push({
    source: graph.nodes[v.id],
    target: graph.nodes[v.neighbor1],
    x1: graph.nodes[v.id].x,
    y1: graph.nodes[v.id].x,
    x2: graph.nodes[v.neighbor1].x,
    y2: graph.nodes[v.neighbor1].y,
  });
  graph.links.push({
    "source": graph.nodes[v.id],
    "target": graph.nodes[v.neighbor2],
    x1: graph.nodes[v.id].x,
    y1: graph.nodes[v.id].x,
    x2: graph.nodes[v.neighbor2].x,
    y2: graph.nodes[v.neighbor2].y,
  });
}

function addLink(e) {
  e.source = graph.nodes[e.source];
  e.target = graph.nodes[e.target];
  e.x1 = e.source.x;
  e.y1 = e.source.y;
  e.x2 = e.target.x;
  e.y2 = e.target.y;
}

// Retrieve graph
var xmlHttp = new XMLHttpRequest();
xmlHttp.overrideMimeType("application/json");
xmlHttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    graph = JSON.parse(this.responseText);
    for (const id in graph.nodes) {
      const n = graph.nodes[id];
      n.x = width/2;
      n.y = height/2;
      if (n.yours === true) {
        showUserAddedANode();
      }
    }
    graph.links.forEach(addLink);
    console.log(graph);
    showGraph();
    recomputeDegrees();
    if (graph.percolation) {
      showPercolation(graph.percolation);
    }
  } else {
    handleAjaxError(this);
  }
};
xmlHttp.open("GET", "/network/getdata");
xmlHttp.send();

</script>
